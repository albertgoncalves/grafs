// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package bst

import (
    "fmt"
    "geom"
)

type GeomPairLabelSegmentNode struct {
    Key   geom.Pair
    Value LabelSegment
    Equal func(geom.Pair, geom.Pair) bool
    Less  func(geom.Pair, geom.Pair) bool
    Left  *GeomPairLabelSegmentNode
    Right *GeomPairLabelSegmentNode
}

func (node *GeomPairLabelSegmentNode) Insert(key geom.Pair, value LabelSegment) error {
    if node == nil {
        return fmt.Errorf("(%v).Insert(%v, %v)", node, key, value)
    }
    if node.Equal(key, node.Key) {
        node.Value = value
        return nil
    }
    if node.Less(key, node.Key) {
        if node.Left == nil {
            node.Left = &GeomPairLabelSegmentNode{
                Key:   key,
                Value: value,
                Equal: node.Equal,
                Less:  node.Less,
            }
            return nil
        }
        return node.Left.Insert(key, value)
    }
    if node.Right == nil {
        node.Right = &GeomPairLabelSegmentNode{
            Key:   key,
            Value: value,
            Equal: node.Equal,
            Less:  node.Less,
        }
        return nil
    }
    return node.Right.Insert(key, value)
}

func (node *GeomPairLabelSegmentNode) Find(key geom.Pair) (LabelSegment, error) {
    if node == nil {
        return LabelSegment{}, fmt.Errorf("(%v).Find(%v)", node, key)
    }
    if node.Equal(key, node.Key) {
        return node.Value, nil
    }
    if node.Less(key, node.Key) {
        return node.Left.Find(key)
    }
    return node.Right.Find(key)
}

func (node *GeomPairLabelSegmentNode) last(parent *GeomPairLabelSegmentNode) (
    *GeomPairLabelSegmentNode, *GeomPairLabelSegmentNode, error) {
    if node == nil {
        return nil, nil, fmt.Errorf("(%v).last(%v)", node, parent)
    }
    if node.Left == nil {
        return node, parent, nil
    }
    return node.Left.last(node)
}

func (node *GeomPairLabelSegmentNode) first(parent *GeomPairLabelSegmentNode) (
    *GeomPairLabelSegmentNode, *GeomPairLabelSegmentNode, error) {
    if node == nil {
        return nil, nil, fmt.Errorf("(%v).first(%v)", node, parent)
    }
    if node.Right == nil {
        return node, parent, nil
    }
    return node.Right.first(node)
}

func (node *GeomPairLabelSegmentNode) swap(
    parent,
    replacement *GeomPairLabelSegmentNode,
) error {
    if node == nil {
        return fmt.Errorf("(%v).swap(%v, %v)", node, parent, replacement)
    }
    if node == parent.Left {
        parent.Left = replacement
        return nil
    }
    parent.Right = replacement
    return nil
}

func (node *GeomPairLabelSegmentNode) Delete(
    key geom.Pair,
    parent *GeomPairLabelSegmentNode,
) error {
    if node == nil {
        return fmt.Errorf("(%v).Delete(%v, %v)", node, key, parent)
    }
    if node.Equal(key, node.Key) {
        if (node.Left == nil) && (node.Right == nil) {
            node.swap(parent, nil)
            return nil
        }
        if node.Left == nil {
            node.swap(parent, node.Right)
            return nil
        }
        if node.Right == nil {
            node.swap(parent, node.Left)
            return nil
        }
        replacement, replParent, err := node.Left.first(node)
        if err != nil {
            return err
        }
        node.Key = replacement.Key
        node.Value = replacement.Value
        node.Equal = replacement.Equal
        node.Less = replacement.Less
        return replacement.Delete(replacement.Key, replParent)
    }
    if node.Less(key, node.Key) {
        return node.Left.Delete(key, node)
    }
    return node.Right.Delete(key, node)
}

type GeomPairLabelSegmentTuple struct {
    Key   geom.Pair
    Value LabelSegment
}

type GeomPairLabelSegmentTree struct {
    Root  *GeomPairLabelSegmentNode
    Stack []GeomPairLabelSegmentTuple
    Equal func(geom.Pair, geom.Pair) bool
    Less  func(geom.Pair, geom.Pair) bool
}

func (tree *GeomPairLabelSegmentTree) Insert(key geom.Pair, value LabelSegment) error {
    if tree.Root == nil {
        tree.Root = &GeomPairLabelSegmentNode{
            Key:   key,
            Value: value,
            Equal: tree.Equal,
            Less:  tree.Less,
        }
        return nil
    }
    return tree.Root.Insert(key, value)
}

func (tree *GeomPairLabelSegmentTree) Find(key geom.Pair) (LabelSegment, error) {
    if tree.Root == nil {
        return LabelSegment{}, fmt.Errorf("(%v).Find(%v)", tree, key)
    }
    value, err := tree.Root.Find(key)
    if err != nil {
        return LabelSegment{}, err
    }
    return value, nil
}

func (tree *GeomPairLabelSegmentTree) Pop() (geom.Pair, LabelSegment, error) {
    if tree.Root == nil {
        return geom.Pair{}, LabelSegment{}, fmt.Errorf("(%v).Pop()", tree)
    }
    node, parent, err := tree.Root.Right.first(tree.Root)
    if err != nil {
        key := tree.Root.Key
        value := tree.Root.Value
        tree.Root = tree.Root.Left
        return key, value, nil
    }
    key := node.Key
    value := node.Value
    node.Delete(node.Key, parent)
    return key, value, nil
}

func (tree *GeomPairLabelSegmentTree) Empty() bool {
    return tree.Root == nil
}

func (tree *GeomPairLabelSegmentTree) Delete(key geom.Pair) error {
    if tree.Root == nil {
        return fmt.Errorf("(%v).Delete(%v)", tree, key)
    }
    pseudoParent := &GeomPairLabelSegmentNode{Right: tree.Root}
    if err := tree.Root.Delete(key, pseudoParent); err != nil {
        return err
    }
    tree.Root = pseudoParent.Right
    return nil
}

func (tree *GeomPairLabelSegmentTree) traverse(node *GeomPairLabelSegmentNode) {
    if node != nil {
        tree.traverse(node.Left)
        tree.Stack = append(
            tree.Stack,
            GeomPairLabelSegmentTuple{node.Key, node.Value},
        )
        tree.traverse(node.Right)
    }
}

func (tree *GeomPairLabelSegmentTree) Collect() []GeomPairLabelSegmentTuple {
    tree.Stack = make([]GeomPairLabelSegmentTuple, 0)
    if tree.Root != nil {
        tree.traverse(tree.Root)
    }
    return tree.Stack
}
